



class ConnectionManager {
    static version = [1,0,1];

    static BLINK_ALWAYS = 0;
    static BLINK_NEVER = 1;
    static BLINK_ON_CONNECT = 2;
    static BLINK_ON_DISCONNECT = 3;

    static CONNECTION_TIMEOUT = 60; 

    
    _checkTimeout = null;
    _stayConnected = null;
    _blinkupBehavior = null;
    _retry = null;

    
    _onConnect = null;
    _onFail = null;
    _onDisconnect = null;

    
    _connected = null;
    _connecting = null;

    
    _queue = null;
    _logs = null;

    constructor(settings = {}) {
        
        _checkTimeout = ("checkTimeout" in settings) ? settings.checkTimeout : 5;
        _stayConnected = ("stayConnected" in settings) ? settings.stayConnected : false;
        _blinkupBehavior = ("blinkupBehavior" in settings) ? settings.blinkupBehavior : BLINK_ON_DISCONNECT;
        _retry = ("retry" in settings) ? settings.retry : true;
        local startDisconnected = ("startDisconnected" in settings) ? settings.startDisconnected : false;

        
        _queue = [];
        _logs = [];

        
        server.setsendtimeoutpolicy(RETURN_ON_ERROR, WAIT_TIL_SENT, 30);

        
        if (startDisconnected) {
            server.disconnect();
            _connected = false;
        }

        
        _setBlinkUpState();

        
        _watchdog();
    }

    
    
    
    
    
    
    
    function onConnect(callback) {
        _onConnect = callback;

        return this;
    }

    function onFail(callback) {
        _onFail = callback;

        return this;
    }

    
    
    
    
    
    
    
    
    
    function onDisconnect(callback) {
        _onDisconnect = callback;

        return this;
    }

    
    function isConnected() {
        return _connected;
    }

    
    
    
    function connect() {
        
        if (_connecting) return false;

        
        if (_connected) {
            _onConnectedFlow();
            return true;;
        }

        

        
        _connecting = time();
        server.connect(function(result) {
            
            _connecting = false;
            if (result == SERVER_CONNECTED) {
                
                _connected = true;
                _onConnectedFlow();
            } else {
                
                _onTimeoutFlow();
            }
        }.bindenv(this));

        
        if (server.isconnected()) {
            _connecting = false;
            _connected = true;
            _onConnectedFlow();
        }

        return true;
    }

    
    function disconnect() {
        
        if (_connecting) { return false; }

        
        if (!_connected) {
            _onDisconnectedFlow(true);
            return true;
        }

        
        server.flush(30);
        server.disconnect();

        
        _connected = false;

        
        _onDisconnectedFlow(true);

        return true;
    }

    
    
    
    
    
    
    
    
    function onNextConnect(callback) {
        _queue.push(callback);
        _processQueue();
        return this;
    }

    
    
    function connectFor(callback) {
        local cb = _connectForCallbackFactory(callback);
        _queue.push(cb);
        connect();
    }

    
    
    
    
    
    
    function setBlinkUpBehavior(state) {
        _blinkupBehavior = state;
        _setBlinkUpState();

        return this;
    }

    function log(obj, error = false) {
        if (_connected) {
            server.log(obj.tostring());
        } else {
            _logs.push({ "ts": time(), "error": 0, "log": obj.tostring() });
        }
    }

    function error(obj) {
        log(obj, true);
    }

    

    
    
    function _connectForCallbackFactory(callback) {
        return function() {
            callback();
            disconnect();
        }.bindenv(this);
    }

    
    
    function _watchdog() {
        
        imp.wakeup(_checkTimeout, _watchdog.bindenv(this));

        
        if (_connecting) {
            if (time() - _connecting >= CONNECTION_TIMEOUT) {
                _onTimeoutFlow()
            }
            return;
        }

        
        local connected = server.isconnected()

        
        if (_connected == connected) return;

        
        _connected = connected;

        
        if (connected) {
            _onConnectedFlow();
        } else {
            _onDisconnectedFlow(false);
        }
    }

    
    function _onTimeoutFlow() {
        
        _setBlinkUpState();

        if (_retry) {
            
            _connecting = false;
            imp.wakeup(0, connect.bindenv(this));
        } else {
            _connected = false;
            if (_onFail) _onFail();
        }
    }


    
    function _onConnectedFlow() {
        
        _setBlinkUpState();

        while(_logs.len() > 0) {
            local log = _logs.remove(0);
            if (!log.error) {
                server.log(log.ts + " - " + log.log)
            } else {
                server.error(log.ts + " - " + log.log)
            }
        }

        
        if (_onConnect != null) {
            imp.wakeup(0, function() { _onConnect(); }.bindenv(this));
        }

        _processQueue();
    }

    
    function _onDisconnectedFlow(expected) {
        
        _setBlinkUpState();

        
        if (_onDisconnect != null) {
            imp.wakeup(0, function() { _onDisconnect(expected); }.bindenv(this));
        }

        if (_stayConnected) {
            imp.wakeup(0, connect.bindenv(this));
        }
    }

    
    
    function _processQueue() {
        
        if (_queue.len() == 0 || _connecting || !_connected) return;

        local cb = _queue.remove(0);
        imp.wakeup(0, function() {
            
            cb();
            
            _processQueue();
        }.bindenv(this));
    }

    
    function _setBlinkUpState() {
        
        if (_blinkupBehavior == BLINK_ALWAYS) {
            imp.enableblinkup(true);
            return;
        }
        
        if (_blinkupBehavior == BLINK_NEVER) {
            imp.enableblinkup(false);
            return;
        }

        
        if ((_connected && _blinkupBehavior == BLINK_ON_CONNECT)
        || (!_connected && _blinkupBehavior == BLINK_ON_DISCONNECT)) {
            imp.enableblinkup(true);
        } else {
            imp.enableblinkup(false);
        }
    }
}











class WifiQueue {

	
	_wifiList = null;
	_cm = null;
	_connecting = false;
	_currentNetwork = null;

	constructor(wifiList) {

		_wifiList = wifiList;
		_cm = ConnectionManager({
			"blinkupBehavior": ConnectionManager.BLINK_NEVER,
			"startDisconnected": false,
			"retry": false,
			"stayConnected": false
		});

	}

	
	function disconnect() {
		_cm.disconnect();
	}

	
	function init() {

		
		_cm.onConnect(function() {

			_connecting = false;
			logs.write("Successfully connected to network " + _currentNetwork + "\r\n");

		}.bindenv(this));

		
		_cm.onFail(function() {

			_connecting = false;

			logs.write("Could not connect to network " + _currentNetwork + "\r\n");

			if (_currentNetwork == (_wifiList.len() - 1)) {
				logs.write("Failed to connect to any network\r\n");
				logs.write("Connecting to IndepStudiosUP...")
				imp.setwificonfiguration("IndepStudiosUP", "lightmyfiretwenty");
				return;
			}

			_currentNetwork++;
			connect();

		}.bindenv(this));

	}

	
	
	function connect() {

		if (_cm.isConnected()) {
			logs.write("Already connected\r\n");
			return;
		}
		if (_connecting == true) {
			logs.write("Already trying to connect\r\n");
			return;
		}
		_currentNetwork = _currentNetwork || 0; 
		_connecting = true;

		local network = _wifiList[_currentNetwork];

		imp.setwificonfiguration(network.ssid, network.pw);
		logs.write("Trying to connect...\r\n");
		_cm.connect();

	}

}


wifiList <- [
	{"ssid": "test1", "pw": "test1"},
	{"ssid": "test2", "pw": "test2"},
	{"ssid": "IndepStudiosUP", "pw": "lightmyfiretwenty"}
];





logs <- hardware.uart12;
logs.configure(9600, 8, PARITY_NONE, 1, NO_CTSRTS);
logs.write("I'm alive\r\n");

imp.wakeup(5, function() {
	wq <- WifiQueue(wifiList);
	wq.disconnect();
	wq.init();
	wq.connect();
}.bindenv(this));
